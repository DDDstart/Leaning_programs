'''
Функция должна быть объявлена ранее первого вызова.
Объявление функции поиска минимума среди двух чисел
'''
def min2(a, b):
    if a<= b:
        return a
    else:
        return b

#       
'''
Пример вызова этой функции
'''
# Минимум из чисел 42 и 30
m = min2(42, 30)

# Минимум из чисел 42, 30 и 25
m = min2(min2(42, 30), 25)

# Вычисление зеачения выражения с помощью функции
n = 10
def f(n):
    return n * 10 + 5
x = f(f(f(n)))
print(x) # x = 10555

#
'''
Использование ПРОИЗВОЛЬНОГО числа параметров в функции
'''
def min(*a):    # * указывает на то, что у функции произвольное число параметров
    m = a[0]
    for x in a:
        if m > x:
            m = x
    return

#
'''
Переменные, объявленные внутри функции, являются локальными и доступны только внутри этой функции
(их значение не влияет на такие же переменные в программе снаружи функции)
'''

#
'''
Изменение объектов, связанных с локальными переменными
'''
def append_zero(xs):
    xs.append(0) # Функция, добавляющая 0 в конец списка
a = []
append_zero(a) # Вызов функции
print(a) # Рузультат [0]

#
'''
Глобальные переменные
'''
def print_value():
    print(a)
a = 5   # a является глобальной переменной
print_value()   # Результат 5

#
'''Напишите функцию f(x), которая возвращает значение следующей функции, определённой на всей числовой прямой
Требуется реализовать только функцию, решение не должно осуществлять операций ввода-вывода.'''
def f(x):
    if x <= -2:
        return 1 - (x + 2)**2
    if x > -2 and x <= 2:
        return -x / 2
    if x > 2:
        return (x - 2)**2 + 1

# Решение в две строки:
def f(x):
    return float(x<-2 and 1-(x+2)**2 or 2<x and (x-2)**2+1 or -2<=x<=2 and -x/2)

# Решение с помощью if, elif, else:
def f(x):
    if x <= -2:
        return 1 - (x + 2) ** 2
    elif x <= 2:
        return -x / 2
    else:
        return (x - 2) ** 2 + 1

# Или так:
def f(x):
    if x<=-2:
        return -(x+1)*(x+3)
    elif 2<x:
        return (x-2)*(x-2)+1
    return -x/2

#
'''Напишите функцию modify_list(l), которая принимает на вход список целых чисел,
удаляет из него все нечётные значения, а чётные нацело делит на два.
Функция не должна ничего возвращать, требуется только изменение переданного списка, например:
lst = [1, 2, 3, 4, 5, 6]
print(modify_list(lst))  # None
print(lst)               # [1, 2, 3]
modify_list(lst)
print(lst)               # [1]

lst = [10, 5, 8, 3]
modify_list(lst)
print(lst)               # [5, 4]'''

l = [1, 2, 3, 4, 5, 6]
def modify_list(l):
    ll = []
    for i in range(len(l)):
        if l[i] % 2 == 0:
            ll.append(int(l[i] / 2))
    l.clear()           # Очищаем список (так же можно очищать так: del l[:])
    l.extend(ll)        # Добавляем в список полностью другой список
modify_list(l)
print(l)

'''
Можно заменить 
l.clear()    
l.extend(ll)
на 
l[:] = ll   # всем элементам l присвоить новые значения из ll
'''

# Другое решение:
def modify_list(l):
    l[:] = [i//2 for i in l if not i % 2]

# Другое решение (делает бесполезную работу по удалению нечетных чисел):    
def modify_list(l):
    i=0
    while i<len(l):
        if l[i]%2 !=0:
            del (l[i])
        else:
            l[i]=l[i]//2 
            i+=1

# Другое решение:
''' По факту собираем новый список прямо в хвосте предыдущего, добавляя в конец списка чётные числа, поделенные на 2,
а все исходные элементы списка - удаляем. for x in l[:] - перебор элементов ведём по копии списка, полученной с помощью среза,
т.к. исходный список мы меняем прямо во время прохода, а в этом случае простой поэлементный перебор "ломается".'''
def modify_list(l):
    for x in l[:]:
        if x % 2 == 0:
            l.append(x//2)
        l.remove(x)

# Другое решение:
